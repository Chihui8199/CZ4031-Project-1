1. Look for key to delete recursively
    - Check if key is leaf -> delete   
    - else, continue to check the children

    After Deleting key from leaf node, check if deleted key is a lower bound  
    -if yes, verify whether the leaf node can obtain a new lower bound by using the right key from the deleted key.
        -Update the tree recursively
    -if no, lowerbound remains the same 

    Check if tree is balance (resursively)
    1. Check if leaf node is balance
        1. Check if we can redistribute with next (Borrow from left: move one key from left to right)
        2. Check if we can redistribute with prev (Borrow from right: move one key from right to left)
        3. If neither the adjacent sibling can be used -> merge the two nodes -> Adjust the parent -> if parent is not fill recusively apply deletion algorithm
            a. first try merge with left node
            b. second try merge with right node

    
    -----------
    Borrow from left
    1. (Redistribute) get last key from giver and add it to first pos receivernode 
    2. Remove giver key from the giver node's map

    
    Borrow from right
    1. (Redistribute) get first key from giver and add it to last pos receivernode 
    2. Remove giver key from the giver node's map
    
    After borrowing the keys, check if giver is from the same parent
    - if yes, update parent @ index+1 with firstkey

    updateKey at higher levels with the correct lowerbound

    
    *EXTRA (Edge cases we did not look into):
    - MERGE NODE WITH PREVIOUS / NEXT NODE'S PARENT IF CURRENT PARENT DOES NOT FULFIL MIN NODE SIZE REQ
    - DELETING LAST KEY WILL AFFECT ROOT NODE 

    ----------
    Merge to left
    -Check if previous node exists
    -Set the previous pointer of the previous node to the current node's next node
    -Set the next pointer of the current node's next node to the next node
    -Check if parent key satisfy min node size then remove current node from parent if it is empty

    Merge to right
    -Check if next node exists
    -Set the previous pointer of the next node to the current node's previous node
    -Set the next pointer of the current node's previous node to the next node
    -Check if parent key satisfy min node size then remove current node from parent if it is empty
    
    After merging, UpdateKey at higher levels with the correct lowerbound

    




    2. Check if non-leaf node is balance
        1. Check if we can redistribute with next non-leaf node (Borrow from left: move one key from left to right)
        2. Check if we can redistribute with prev non-leaf node (Borrow from right: move one key from right to left)
        3. If neither the adjacent sibling can be used -> merge the two nodes -> Adjust the parent -> if parent is not fill recusively apply deletion algorithm
            a. first try merge with left node
            b. second try merge with right node


    ----------
    Borrow one key from non leaf node
    1. (Redistribute) get last key from giver non leaf node to the receiver non leaf node
    2. Remove child from the giver node
    3. Add child to the non leaf node
    4. Remove giver key from the giver node's map
    5. UpdateKey parent key
    6. Update higher levels with the correct lowerbound

    -----------
    Merge non-leaf node with sibling
    -Check if sibling node exists
    -add the keys from the current node to the keys of the previous sibling node
    -Remove children from current node
    -Add the children of the current node to the previous sibling node
    -Check if parent key satisfy min node size then remove current node from parent if it is empty
    -After merging, UpdateKey at higher levels with the correct lowerbound

    

    
